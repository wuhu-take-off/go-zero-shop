// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: shop.proto

package shop

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserServe_UserLogin_FullMethodName = "/shop.UserServe/UserLogin"
)

// UserServeClient is the client API for UserServe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServeClient interface {
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
}

type userServeClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServeClient(cc grpc.ClientConnInterface) UserServeClient {
	return &userServeClient{cc}
}

func (c *userServeClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, UserServe_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServeServer is the server API for UserServe service.
// All implementations must embed UnimplementedUserServeServer
// for forward compatibility
type UserServeServer interface {
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	mustEmbedUnimplementedUserServeServer()
}

// UnimplementedUserServeServer must be embedded to have forward compatible implementations.
type UnimplementedUserServeServer struct {
}

func (UnimplementedUserServeServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserServeServer) mustEmbedUnimplementedUserServeServer() {}

// UnsafeUserServeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServeServer will
// result in compilation errors.
type UnsafeUserServeServer interface {
	mustEmbedUnimplementedUserServeServer()
}

func RegisterUserServeServer(s grpc.ServiceRegistrar, srv UserServeServer) {
	s.RegisterService(&UserServe_ServiceDesc, srv)
}

func _UserServe_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServeServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserServe_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServeServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserServe_ServiceDesc is the grpc.ServiceDesc for UserServe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserServe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shop.UserServe",
	HandlerType: (*UserServeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserLogin",
			Handler:    _UserServe_UserLogin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shop.proto",
}

const (
	GoodsServe_GoodsList_FullMethodName   = "/shop.GoodsServe/GoodsList"
	GoodsServe_GoodsAdd_FullMethodName    = "/shop.GoodsServe/GoodsAdd"
	GoodsServe_GoodsUpdate_FullMethodName = "/shop.GoodsServe/GoodsUpdate"
	GoodsServe_GoodsDel_FullMethodName    = "/shop.GoodsServe/GoodsDel"
)

// GoodsServeClient is the client API for GoodsServe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GoodsServeClient interface {
	// 获取商品列表
	GoodsList(ctx context.Context, in *GoodsListReq, opts ...grpc.CallOption) (*GoodsListResp, error)
	// 添加商品
	GoodsAdd(ctx context.Context, in *GoodsAddReq, opts ...grpc.CallOption) (*GoodsAddResp, error)
	// 更新商品
	GoodsUpdate(ctx context.Context, in *GoodsUpdateReq, opts ...grpc.CallOption) (*GoodsUpdateResp, error)
	// 删除山炮
	GoodsDel(ctx context.Context, in *GoodsDelReq, opts ...grpc.CallOption) (*GoodsDelResp, error)
}

type goodsServeClient struct {
	cc grpc.ClientConnInterface
}

func NewGoodsServeClient(cc grpc.ClientConnInterface) GoodsServeClient {
	return &goodsServeClient{cc}
}

func (c *goodsServeClient) GoodsList(ctx context.Context, in *GoodsListReq, opts ...grpc.CallOption) (*GoodsListResp, error) {
	out := new(GoodsListResp)
	err := c.cc.Invoke(ctx, GoodsServe_GoodsList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goodsServeClient) GoodsAdd(ctx context.Context, in *GoodsAddReq, opts ...grpc.CallOption) (*GoodsAddResp, error) {
	out := new(GoodsAddResp)
	err := c.cc.Invoke(ctx, GoodsServe_GoodsAdd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goodsServeClient) GoodsUpdate(ctx context.Context, in *GoodsUpdateReq, opts ...grpc.CallOption) (*GoodsUpdateResp, error) {
	out := new(GoodsUpdateResp)
	err := c.cc.Invoke(ctx, GoodsServe_GoodsUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *goodsServeClient) GoodsDel(ctx context.Context, in *GoodsDelReq, opts ...grpc.CallOption) (*GoodsDelResp, error) {
	out := new(GoodsDelResp)
	err := c.cc.Invoke(ctx, GoodsServe_GoodsDel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GoodsServeServer is the server API for GoodsServe service.
// All implementations must embed UnimplementedGoodsServeServer
// for forward compatibility
type GoodsServeServer interface {
	// 获取商品列表
	GoodsList(context.Context, *GoodsListReq) (*GoodsListResp, error)
	// 添加商品
	GoodsAdd(context.Context, *GoodsAddReq) (*GoodsAddResp, error)
	// 更新商品
	GoodsUpdate(context.Context, *GoodsUpdateReq) (*GoodsUpdateResp, error)
	// 删除山炮
	GoodsDel(context.Context, *GoodsDelReq) (*GoodsDelResp, error)
	mustEmbedUnimplementedGoodsServeServer()
}

// UnimplementedGoodsServeServer must be embedded to have forward compatible implementations.
type UnimplementedGoodsServeServer struct {
}

func (UnimplementedGoodsServeServer) GoodsList(context.Context, *GoodsListReq) (*GoodsListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoodsList not implemented")
}
func (UnimplementedGoodsServeServer) GoodsAdd(context.Context, *GoodsAddReq) (*GoodsAddResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoodsAdd not implemented")
}
func (UnimplementedGoodsServeServer) GoodsUpdate(context.Context, *GoodsUpdateReq) (*GoodsUpdateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoodsUpdate not implemented")
}
func (UnimplementedGoodsServeServer) GoodsDel(context.Context, *GoodsDelReq) (*GoodsDelResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoodsDel not implemented")
}
func (UnimplementedGoodsServeServer) mustEmbedUnimplementedGoodsServeServer() {}

// UnsafeGoodsServeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GoodsServeServer will
// result in compilation errors.
type UnsafeGoodsServeServer interface {
	mustEmbedUnimplementedGoodsServeServer()
}

func RegisterGoodsServeServer(s grpc.ServiceRegistrar, srv GoodsServeServer) {
	s.RegisterService(&GoodsServe_ServiceDesc, srv)
}

func _GoodsServe_GoodsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoodsListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoodsServeServer).GoodsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoodsServe_GoodsList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoodsServeServer).GoodsList(ctx, req.(*GoodsListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoodsServe_GoodsAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoodsAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoodsServeServer).GoodsAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoodsServe_GoodsAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoodsServeServer).GoodsAdd(ctx, req.(*GoodsAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoodsServe_GoodsUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoodsUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoodsServeServer).GoodsUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoodsServe_GoodsUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoodsServeServer).GoodsUpdate(ctx, req.(*GoodsUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GoodsServe_GoodsDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GoodsDelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GoodsServeServer).GoodsDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GoodsServe_GoodsDel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GoodsServeServer).GoodsDel(ctx, req.(*GoodsDelReq))
	}
	return interceptor(ctx, in, info, handler)
}

// GoodsServe_ServiceDesc is the grpc.ServiceDesc for GoodsServe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GoodsServe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shop.GoodsServe",
	HandlerType: (*GoodsServeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GoodsList",
			Handler:    _GoodsServe_GoodsList_Handler,
		},
		{
			MethodName: "GoodsAdd",
			Handler:    _GoodsServe_GoodsAdd_Handler,
		},
		{
			MethodName: "GoodsUpdate",
			Handler:    _GoodsServe_GoodsUpdate_Handler,
		},
		{
			MethodName: "GoodsDel",
			Handler:    _GoodsServe_GoodsDel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shop.proto",
}

const (
	FunctionServe_SendEmailAuth_FullMethodName = "/shop.FunctionServe/SendEmailAuth"
)

// FunctionServeClient is the client API for FunctionServe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FunctionServeClient interface {
	SendEmailAuth(ctx context.Context, in *SendEmailAuthReq, opts ...grpc.CallOption) (*SendEmailAuthResp, error)
}

type functionServeClient struct {
	cc grpc.ClientConnInterface
}

func NewFunctionServeClient(cc grpc.ClientConnInterface) FunctionServeClient {
	return &functionServeClient{cc}
}

func (c *functionServeClient) SendEmailAuth(ctx context.Context, in *SendEmailAuthReq, opts ...grpc.CallOption) (*SendEmailAuthResp, error) {
	out := new(SendEmailAuthResp)
	err := c.cc.Invoke(ctx, FunctionServe_SendEmailAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FunctionServeServer is the server API for FunctionServe service.
// All implementations must embed UnimplementedFunctionServeServer
// for forward compatibility
type FunctionServeServer interface {
	SendEmailAuth(context.Context, *SendEmailAuthReq) (*SendEmailAuthResp, error)
	mustEmbedUnimplementedFunctionServeServer()
}

// UnimplementedFunctionServeServer must be embedded to have forward compatible implementations.
type UnimplementedFunctionServeServer struct {
}

func (UnimplementedFunctionServeServer) SendEmailAuth(context.Context, *SendEmailAuthReq) (*SendEmailAuthResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEmailAuth not implemented")
}
func (UnimplementedFunctionServeServer) mustEmbedUnimplementedFunctionServeServer() {}

// UnsafeFunctionServeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FunctionServeServer will
// result in compilation errors.
type UnsafeFunctionServeServer interface {
	mustEmbedUnimplementedFunctionServeServer()
}

func RegisterFunctionServeServer(s grpc.ServiceRegistrar, srv FunctionServeServer) {
	s.RegisterService(&FunctionServe_ServiceDesc, srv)
}

func _FunctionServe_SendEmailAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEmailAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FunctionServeServer).SendEmailAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FunctionServe_SendEmailAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FunctionServeServer).SendEmailAuth(ctx, req.(*SendEmailAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

// FunctionServe_ServiceDesc is the grpc.ServiceDesc for FunctionServe service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FunctionServe_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shop.FunctionServe",
	HandlerType: (*FunctionServeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEmailAuth",
			Handler:    _FunctionServe_SendEmailAuth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shop.proto",
}
